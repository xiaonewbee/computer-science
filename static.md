   2、与const成员变量相对应的是static成员变量。当**static**修饰成员变量的时候，表示相应的成员变量直接**属于类本身**，为类生成的所有**对象共有。**我们在统计对象的数量时，可以通过使用static成员变量来实现。**同时static相当于一个范**围限定符，它限定所修饰的成员变量为**该文件所特有。**

————————————————

​     类的static成员变量，在**类体外**完成**初始化，例：**

> 为什么？
>
> 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
>
> 初始化对于**公共的和非公共**的静态数据成员是合法的，但是**对非公共**的静态数据成员进行**赋值**却是不合法的。比如，如果count是private的，那么Point::count = 0就是错误的。



> 必须被显式初始化：
>
> 全局变量可以被隐式地初始化为0，而静态成员变量作为类的数据成员，必须被显式地初始化，因为类的所有的数据成员都必须被显式初始化。

 但为什么static const int就可以在类里面初始化呢？ 

const就是只读的意思,只在声明中使用;
static一般有2个作用,规定**作用域**和**存储方式**.

对于局部变量,static规定其为静态存储方式,每次调用的初始值为上一次调用的值,调用结束后存储空间不释放;
对于全局变量,如果以文件划分作用域的话,此变量只在当前文件可见;对于static函数也是在当前模块内函数可见.

static const 应该就是上面两者的合集.

static const,既是只读的,又是只在当前模块中可见的.

> 

```c++
class B
{
	public:
		B(){}
	private:
		static int a;
};
int B::a=2;//在类外初始化时，省略掉static，避免与其他全局static变量混淆
```

//在类外初始化时，**省略掉static**，避免与其他全局static变量混淆

 **static成员函数没有this指针**，所以不能访问类内的数据成员。只能访问静态成员变量

## C++成员函数和静态成员函数调用区别

| 属性         | 调用方法                                                     |
| ------------ | ------------------------------------------------------------ |
| 静态成员函数 | C++ 的静态成员函数调用方法有两种，一种是通过 “类名::成员函数名” 的方法，另一种是通过 “对象.成员函数名” 的方法来调用。 |
| 成员函数     | C++ 的普通成员变量只能通过 “对象.成员函数名” 的方法来调用。  |
