- ①我们可以将基类的指针或引用绑定到派生对象上

```javascript
#include <iostream>class A {};class B:public A{};int main(){	A *a;	B b;	a = &b;	return 0;}
```



- ②即使不是指针/引用类型，我们也可以将派生类转换为基类

```javascript
#include <iostream>class A {};class B:public A{};int main(){	A a;	B b;	a = b;	return 0;}
```



- ②不能将基类对象绑定到派生类的指针/引用上

```javascript
A a;B *b;b = &a; //程序错误，不能将基类对象转换为派生类对象
```









![img](https://ask.qcloudimg.com/http-save/yehe-3479834/5n0h8cop7y.png?imageView2/2/w/1620)

https://cloud.tencent.com/developer/article/1784483

- 派生类可以转换为基类的本质是：
  - ①为什么派生类可以转换为基类：派生类从基类而来，因此派生类中包含了基类的方法和成员。此时基类可以通过指针或引用指向派生类（相当于将派生类从基类中继承的那部分方法和成员绑定到基类上了，相当于派生类被截断了），然后基类就可以将派生类假装是一个基类对象来使用（调用其中的成员/方法）
  - ②为什么基类不能转换为派生类：因为派生类可能会定义自己新的成员/方法，但是这些成员/方法是基类中所没有的。如果将一个基类对象绑定到派生类的指针/引用上，此时派生类通过指针/引用访问自己新定义的成员/方法时，发现找不到（因此不能将基类转换为派生类）





保护或者私有继承

- 下面案例我们先将派生类转换为基类，然后再将基类转换为派生类，这样是错的

```javascript
//假设B公有继承于A
A *a;
B b;
a = &b;   //将派生类转换为基类，正确
B *p = a; //将基类再转换为派生类，错误
```

- 如果表达式既不是引用也不是指针，那么其就没有静态类型和动态类型的概念，因为其只能与自己类型一致的对象绑定到一起

- 当我们使用基类的引用（或指针）时，我们并不清楚该引用（或指针）所绑定的对象的真实类型，该对象可能是基类的对象，也可能是派生类的对象。只有在程序运行的时候我们才知道所绑定的对象的真实类型

但是访问规则只与指针/引用的类类型有关，而与指针/引用指向的类型无关。

- 转换之后，**基类只能**通过派生类**访问属于自己（基类）的那一部**分，而不**能访问属于派生类**的数据成员（见下面演示案例③）



```c++
class A
{
public:
    int a = 10;
    void show1() const { cout << "A:show1\n"; }
    virtual void show2() const { cout << "A:show2\n"; }
};
class B : public A
{
public:
    int a = 15;
    void show1() const { cout << "B:show1\n"; }
    virtual void show2() const { cout << "B:show2\n"; }
};
int main()
{
    A a;
    B b;
    A *pa = &b;
    cout << pa->a << endl;
    pa->show1();
    pa->show2();
    return 0;
}
```

- 结果分析：
  - 打印10：因为B继承于A，将b转换为A类对象的指针，访问是跟指针的类型有关，而与指针所指的类对象类型无关，因此访问A的a，打印10
  - 打印“A:show1”：因为show1()不是虚函数，所以访问时跟指针的类型有关，此处指针的类型为A，因此访问A的show1函数
  - 打印“B:show2”：因为show2()函数为虚函数，所以**根据虚函数的性质，使用基类的指针访问子类时，访问虚函数跟指针所指的类对象类型有关**，此处指针所指的类类型为B，因此访问B的show2()函数

![img](https://ask.qcloudimg.com/http-save/yehe-3479834/5o8tjkksgp.png?imageView2/2/w/1620)

作者的另一种情况

- 打印“A:show2”：虽然show2()函数为虚函数，但是多态只有发生在基类指针/引用指向于派生类的情况下才会发生，此处基类是普通对象，而不是引用/指针，因此访问的还是A中的show2()函数