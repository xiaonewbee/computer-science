数据量为

` 2 <= n <= 10^5 `

找一个算法为nlogn 的复杂度



数字 & 运算

int m ;

` if( (m & 1) != 0 )` 

用来判断m最末尾是否为0 

...

长度为1000 o^2 就有可能是最优解了



1.

题目：

有一排正数，玩家A和玩家B都可以看到。

每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。

玩家A先拿，玩家B再拿，两人交替拿走所有的数字，

两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。



例如：

5,2,3,4

玩家A先拿，当前他只能拿走5或者4。

如果玩家A拿走5，那么剩下2，3，4。轮到玩家B，此时玩家B可以选择2或4中的一个，…

如果玩家A拿走4，那么剩下5，2，3。轮到玩家B，此时玩家B可以选择5或3中的一个，…



先发后发拿东西，看两个人谁拿的分数多，递归

有个避免递归的方法，避免两次的递归  

![Snipaste_2022-07-24_15-10-35](D:\路径不动的文件\图片\左神\Snipaste_2022-07-24_15-10-35.png)

两个递归表，dp表，可以穷举所有结果

![Snipaste_2022-07-24_15-13-27](D:\路径不动的文件\图片\左神\Snipaste_2022-07-24_15-13-27.png)

依赖图，发现f(1,5) 已经算过了，如果弄一个map把算过了的值记录起来，就好了

首先思路是 给定一个i，j  结果是确定的， 所以他可以用二维表    

二维表要注意你最后想要的值是右上角，有的题答案时右下角

![Snipaste_2022-07-24_15-14-44](D:\路径不动的文件\图片\左神\Snipaste_2022-07-24_15-14-44.png)



































