## 动态绑定





` Animal* mm = new Dog();`

> mm 虽然是动态绑定，但是Animal是静态，mm静态类型为Animal` *`，mm 声明为pointer-to-Animal类型，所以它们都以它为静态类型。注意，不论它们真正指向什么，它们的静态类型都是Animal` *`。

> ​    对象的所谓动态类型（dynamic type）则是指“目前所指对象的类型”。也就是说，动态类型可以表现出一个对象将会有什么行为。以上例而言，mm的动态类型是Dog` *`，

`Shape* ps;    `                 // 静态类型为Shape*

ps没有动态类型，因为它尚未指向任何对象。

---





静态绑定：程序在执行之前就已经解析出应该调用哪一个函数，编译时绑定。

c++中，我们在使用基类的引用（指针）调用虚函数时，就会发生动态绑定。所谓动态绑定，就是在运行时，虚函数会根据绑定对象的实际类型，选择调用函数的版本。

我们知道，**函数调用实**际上是执行函数体中的代码**。函数体**是内存中的一个代码段，**函数名**就表示该代码段的首地址**，函数执行时就从这里**开始。说得简单一点，就是必须要知道**函数的入口地址**，才能成功调用函数。

找到**函数名对应的地址，**然后将**函数调用处用**该**地址替换**，这称为函数绑定，或符号决议。



---

b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &b1 和 &b2)
虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表
由此我们可以总结出:

**同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void\**类型)指向该虚函数表.**

是时候该展示一下类对象的内存布局情况了:

![img](https://img-blog.csdnimg.cn/img_convert/9316dabece92566aa419e2909c57f577.png)

**因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.**
当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.





结果:

1. 现在我们应该知道内幕了! **继承类Derive1的虚函数表被加在基类的后面**! 事实的确就是这样!
2. 由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.
3. 如果基类没有虚函数呢? 这个问题我们留到第9小节再来讨论!

![img](https://img-blog.csdnimg.cn/img_convert/ce3ce0a58f376831281943533131eee7.png)

多继承

![img](https://img-blog.csdnimg.cn/img_convert/ce3ce0a58f376831281943533131eee7.png)

![img](https://img-blog.csdnimg.cn/img_convert/72815741c5727802e482822fec91cef0.png)

1. 按照基类的声明顺序, 基类的成员依次分布在继承中.

## 9.如果第1个直接基类没有虚函数(表)

```cpp

```

所以不难验证: 我们前面的推断是正确的, **谁有虚函数表, 谁就放在前面**!

现在类的布局情况:
![img](https://img-blog.csdnimg.cn/img_convert/b953bc8ddd4ccc05d5f2c0eaf8492329.png)

## 那么, 如果两个基类都没有虚函数表呢?

![img](https://img-blog.csdnimg.cn/img_convert/960282f25e14ce957b9ed5c043204aeb.png)

Ok, 问题解决! 注意高亮的那两行, &d1==&d1.__vfptr, 说明虚函数始终在最前面!

不用再废话, 相信大家对这种情况已经有底了.

## 只需知道: 谁有虚函数表, 谁就往前靠!







由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:把一个继承类强制转换为一个基类是完全可行的.

如果有一个Derive1的指针, 那么:

- 得到Base1的指针: Base1* pb1 = pd1;
- 得到Base2的指针: Base2* pb2 = pd1;
- 得到Base3的指针: Base3* pb3 = pd1;

非常值得注意的是:

这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!
也就是说: 在这里极有可能: **pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!**

至于函数调用, 我想, 不用说大家应该知道了:

1. 如果不是虚函数, 直接调用指针对应的基本类的那个函数
2. 如果是虚函数, 则**查找虚函数表**, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.





如果父类或者祖先类中函数func()为虚函数，则子类及后代类中，函数func()是否加virtual关键字，都将是虚函数。为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。





```

```

我有个虚函数练习21.cpp

这里面讲的挺详细的。