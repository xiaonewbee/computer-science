需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。

这里我们需要重点说一下左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。

迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。

从这一点上看，迭代器和[指针](http://c.biancheng.net/c/80/)类似。

第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是`i != v.end()`。

第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行`++`操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。

### 1.4 泛型编程中结合auto，用于追踪函数的返回值类型

这也是decltype最大的用途了。

```
template <typename T>
auto multiply(T x, T y)->decltype(x*y)
{
	return x*y;
}
```

完整代码见：[decltype.cpp](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/decltype/decltype.cpp)