​        前面我们也说到，计算机每次读写一个字节块，例如，假设计算机**总是从内存中取8个字节**，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据**的地址没有对齐，数据就可能被放在两个8字节块中**，那么我们可能需要**执行两次内存访问**，才能读写完成。显然在这样的情况下，**是低效的**。所以需要字节对齐来提高内存系统性能。

| 类型          | 16位 | 32 位 | 64位 |
| ------------- | ---- | ----- | ---- |
| char          | 1    | 1     | 1    |
| short int     | 2    | 2     | 2    |
| int           | 2    | 4     | 4    |
| unsigned int  | 2    | 4     | 4    |
| float         | 4    | 4     | 4    |
| double        | 8    | 8     | 8    |
| long          | 4    | 4     | 8    |
| long long     | 8    | 8     | 8    |
| unsigned long | 4    | 4     | 8    |

在64位机器中：
        char类型占1个字节
       short类型占2个字节
         int类型占4个字节
        long类型占4个字节
unsigned int类型占4个字节
       float类型占4个字节
      double类型占8个字节
 long double类型占12个字节
-------------------指针占4个字节---------------------
        char类型指针占4个字节
       short类型指针占4个字节
         int类型指针占4个字节
        long类型指针占4个字节
unsigned int类型指针占4个字节
       float类型指针占4个字节
      double类型指针占4个字节
 long double类型指针占4个字节
————————————————


```
#pragma pack(1) /*1字节对齐*/
struct test
{
    int a;
    char b;
    int c;
    short d;
};
#pragma pack()/*还原默认对齐*/
```

