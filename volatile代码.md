例子一：

volatile a;（a是用volatile修饰后）
a=1;
a=2;
a=3;
a=4;
 volatile禁止编译器优化，编译后将产生4条代码。如果没用volatile修饰，编译器会优化上述代码，并认为只有最后1条是有效的，编译后将只产生1条代码，即最后一行。如果中间有其它代码，就不一定了。

```
extern int event_flag
 
void poll_event()
{
while (event_flag == 0) {
    /* 不操作event_flag */
    ....
}
....
}
```

我们不再循环中改变这里的event_flag的值，这样的话，event_flag 看起来就像是多余的，因此**单片机编译器可**能把此程序看为下段程序。

```
void poll_event()
{
if (event_flag == 0) {
    while (1) {
      /* 不对event_flag操作 */
    ....
    }
}
....
}
```

- 对于一般的编译器，一般都会把程序优化成上述程序。这样的优化确实可以提高代码速度，比如while循环中不再需要对条件的判断，所以很快，但是这是正确的吗？

  对于**单线程的程序，这是没有问题的**，因为event_flag 就永远不会改变，但是**对于多线程程序，RTOS的多任务处理的话**，event_flag 的值可能被其他线程改变，这样问题就来了，因为被优化的代码并不具备对用event_flag 变化的能力。因此导致错误的意想不到的结果，如果此代码在ECU上执行的话，那我们的小命可就有可能没了。。。。

  为了避免这种情况，我们使用volatile关键字来防止程序被编译器优化。